/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package srw.mxp.pkgstatic.data.editor;

import java.awt.Component;
import java.awt.Dimension;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.ImageIcon;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileNameExtensionFilter;

/**
 *
 * @author Jonatan
 */
public class UserInterfaceSDE extends javax.swing.JFrame {

    //ArrayList<DataString> data;
    //int current_dialogue = 0;
    int num_categories = 20;
    int current_category = 0;
    int table_size = 0;
    String lastDirectory = ".";
    boolean file_loaded = false;
    String title = "SRW MXP Static Data Editor v1.0 by Dashman";
    String current_file = "";
    
    String font_encoding = "MS932";
    
    byte[] chunk_0 = new byte[0x00033d4c]; // from the beginning to the start of the seishin names
    byte[] chunk_1 = new byte[524]; // seishin names. We don't expect these names to grow (max 12 characters per seishin)
    byte[] chunk_2 = new byte[0x00000a20]; // from the start of the skill data to the start of the Strg block
    byte[] chunk_3; // Strg block
    byte[] chunk_4 = new byte[0x00004aac]; // from the start of the Xunt to the start of the Sent block
    byte[] chunk_5; // Sent block
    byte[] chunk_6; // multi-block
    
    byte[] multi_1 = new byte[416]; // First part of the multi-block (chunk_6)
    
    String[] messages;
    
    int start_Strg = 0x00034978;
    //int size_Strg = 0;
    //int size_Sent = 0;
        
    DataString[][] stringData; // Each row is a category
    
    /**
     * Creates new form UserInterfaceSDE
     */
    public UserInterfaceSDE() {
        DataString d = new DataString();
        d.initMap();    // The map is static in the class, which means it only has to be initialized once.
        
        initComponents();
        
        scrollStrings.getVerticalScrollBar().setUnitIncrement(16);
        
        this.setIconImage(new ImageIcon(getClass().getClassLoader().getResource("resources/icons/MX logo.png")).getImage());
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        scrollStrings = new javax.swing.JScrollPane();
        panelLines = new javax.swing.JPanel();
        panelNavigation = new javax.swing.JPanel();
        labelCategory = new javax.swing.JLabel();
        comboCategory = new javax.swing.JComboBox();
        labelInfo = new javax.swing.JLabel();
        jMenuBar1 = new javax.swing.JMenuBar();
        menuFile = new javax.swing.JMenu();
        menuitemOpen = new javax.swing.JMenuItem();
        jSeparator1 = new javax.swing.JPopupMenu.Separator();
        menuitemSave = new javax.swing.JMenuItem();
        menuitemConvert = new javax.swing.JMenuItem();
        jSeparator2 = new javax.swing.JPopupMenu.Separator();
        menuitemClose = new javax.swing.JMenuItem();
        menuTools = new javax.swing.JMenu();
        menuitemConvertSJIS = new javax.swing.JMenuItem();
        checkSJIS = new javax.swing.JCheckBoxMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("SRW MXP Static Data Editor v1.0 by Dashman");
        setResizable(false);

        scrollStrings.setPreferredSize(new java.awt.Dimension(825, 433));

        javax.swing.GroupLayout panelLinesLayout = new javax.swing.GroupLayout(panelLines);
        panelLines.setLayout(panelLinesLayout);
        panelLinesLayout.setHorizontalGroup(
            panelLinesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 878, Short.MAX_VALUE)
        );
        panelLinesLayout.setVerticalGroup(
            panelLinesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 450, Short.MAX_VALUE)
        );

        scrollStrings.setViewportView(panelLines);

        panelNavigation.setBorder(javax.swing.BorderFactory.createTitledBorder("Navigation"));

        labelCategory.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        labelCategory.setText("Category:");

        comboCategory.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Seishin Names", "Strg - Pilot skill names", "Strg - Unit abilities", "Strg - Unit names + specs", "Strg - Special places (?)", "Strg - Weapon names", "Strg - Character names + VA", "Strg - BGM names", "Strg - Enhance part names", "Sent - Robot Library", "Sent - Character Library", "Sent - Seishin descriptions", "Sent - Pilot skill descriptions", "Sent - Unit ability descriptions", "Sent - Enhance part descriptions", "Sent - Help strings", "Multi - Scene names", "Multi - Location names", "Multi - Stage names", "Multi - Stage descriptions" }));
        comboCategory.setEnabled(false);
        comboCategory.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                comboCategoryActionPerformed(evt);
            }
        });

        labelInfo.setForeground(new java.awt.Color(255, 51, 51));
        labelInfo.setText(" ");

        javax.swing.GroupLayout panelNavigationLayout = new javax.swing.GroupLayout(panelNavigation);
        panelNavigation.setLayout(panelNavigationLayout);
        panelNavigationLayout.setHorizontalGroup(
            panelNavigationLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, panelNavigationLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(labelCategory, javax.swing.GroupLayout.PREFERRED_SIZE, 65, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(comboCategory, javax.swing.GroupLayout.PREFERRED_SIZE, 225, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(labelInfo, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        panelNavigationLayout.setVerticalGroup(
            panelNavigationLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelNavigationLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(panelNavigationLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(labelCategory)
                    .addComponent(comboCategory, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(labelInfo))
                .addContainerGap(14, Short.MAX_VALUE))
        );

        menuFile.setText("File");

        menuitemOpen.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_MASK));
        menuitemOpen.setText("Open...");
        menuitemOpen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuitemOpenActionPerformed(evt);
            }
        });
        menuFile.add(menuitemOpen);
        menuFile.add(jSeparator1);

        menuitemSave.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        menuitemSave.setText("Save as...");
        menuitemSave.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuitemSaveActionPerformed(evt);
            }
        });
        menuFile.add(menuitemSave);

        menuitemConvert.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        menuitemConvert.setText("Convert and Save as...");
        menuitemConvert.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuitemConvertActionPerformed(evt);
            }
        });
        menuFile.add(menuitemConvert);
        menuFile.add(jSeparator2);

        menuitemClose.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ESCAPE, 0));
        menuitemClose.setText("Exit");
        menuitemClose.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuitemCloseActionPerformed(evt);
            }
        });
        menuFile.add(menuitemClose);

        jMenuBar1.add(menuFile);

        menuTools.setText("Tools");

        menuitemConvertSJIS.setText("Convert strings to SJIS");
        menuitemConvertSJIS.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuitemConvertSJISActionPerformed(evt);
            }
        });
        menuTools.add(menuitemConvertSJIS);

        checkSJIS.setText("Convert keystrokes to SJIS");
        menuTools.add(checkSJIS);

        jMenuBar1.add(menuTools);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(scrollStrings, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 880, Short.MAX_VALUE)
                    .addComponent(panelNavigation, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(panelNavigation, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(scrollStrings, javax.swing.GroupLayout.DEFAULT_SIZE, 452, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void comboCategoryActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_comboCategoryActionPerformed
        // TODO add your handling code here:
        int new_category = comboCategory.getSelectedIndex();
        if (new_category != current_category){
            saveCategory();
            current_category = new_category;
            loadCategory();
        }
    }//GEN-LAST:event_comboCategoryActionPerformed

    private void menuitemConvertSJISActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuitemConvertSJISActionPerformed
        // TODO add your handling code here:
        Component[] lines = panelLines.getComponents();

        for (int i = 0; i < lines.length; i++){
            if (current_category == 17){
                PanelStringDouble l = (PanelStringDouble) lines[i];
                l.convertToSJIS();
            }
            else if (current_category == 19){
                PanelStringLarge l = (PanelStringLarge) lines[i];
                l.convertToSJIS();
            }
            else{
                PanelString l = (PanelString) lines[i];
                l.convertToSJIS();
            }
        }
    }//GEN-LAST:event_menuitemConvertSJISActionPerformed

    private void menuitemOpenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuitemOpenActionPerformed
        // TODO add your handling code here:
        JFileChooser chooser = new JFileChooser();
        chooser.setCurrentDirectory(new java.io.File(lastDirectory));
        chooser.setDialogTitle("Load BIN file");
        chooser.setFileFilter(new FileNameExtensionFilter("BIN file", "BIN"));
        if (!current_file.isEmpty())
            chooser.setSelectedFile(new File(current_file));

        if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION){
            current_file = chooser.getSelectedFile().getName();

            openFile(chooser.getSelectedFile().getAbsolutePath());

            lastDirectory = chooser.getSelectedFile().getPath();
        }
    }//GEN-LAST:event_menuitemOpenActionPerformed

    private void menuitemSaveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuitemSaveActionPerformed
        // TODO add your handling code here:
        if (file_loaded){
            JFileChooser chooser = new JFileChooser();
            chooser.setCurrentDirectory(new java.io.File(lastDirectory));
            chooser.setDialogTitle("Save BIN file");
            chooser.setFileFilter(new FileNameExtensionFilter("BIN file", "BIN"));
            if (!current_file.isEmpty())
                chooser.setSelectedFile(new File(current_file));

            saveCategory(); // Save the current category.

            if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION){
                current_file = chooser.getSelectedFile().getName();

                saveFile(chooser.getSelectedFile().getAbsolutePath(), false);

                lastDirectory = chooser.getSelectedFile().getPath();
            }
        }
        else{
            JOptionPane.showMessageDialog(null, "No file loaded!",
                "Error", JOptionPane.ERROR_MESSAGE);
        }
    }//GEN-LAST:event_menuitemSaveActionPerformed

    private void menuitemConvertActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuitemConvertActionPerformed
        // TODO add your handling code here:
        if (file_loaded){
            JFileChooser chooser = new JFileChooser();
            chooser.setCurrentDirectory(new java.io.File(lastDirectory));
            chooser.setDialogTitle("Save BIN file");
            chooser.setFileFilter(new FileNameExtensionFilter("BIN file", "BIN"));
            if (!current_file.isEmpty())
                chooser.setSelectedFile(new File(current_file));

            saveCategory(); // Save the current dialogue, just in case.

            if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION){
                current_file = chooser.getSelectedFile().getName();

                saveFile(chooser.getSelectedFile().getAbsolutePath(), true);

                lastDirectory = chooser.getSelectedFile().getPath();
            }
        }
        else{
            JOptionPane.showMessageDialog(null, "No file loaded!",
                "Error", JOptionPane.ERROR_MESSAGE);
        }
    }//GEN-LAST:event_menuitemConvertActionPerformed

    private void menuitemCloseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuitemCloseActionPerformed
        // TODO add your handling code here:
        this.dispose();
    }//GEN-LAST:event_menuitemCloseActionPerformed

    
    public void openFile(String bin_file){
        parseFile(bin_file);

        if (!file_loaded){
            this.setTitle(title);

            JOptionPane.showMessageDialog(null, "The file didn't have any script text!",
                    "Error", JOptionPane.ERROR_MESSAGE);
        }
        else{
            this.setTitle(current_file + " - " + title);
            loadCategory();
        }
    }
    
    
    public void parseFile(String path){
        RandomAccessFile f;
        file_loaded = false;
        int offset = start_Strg;

        try {
            f = new RandomAccessFile(path, "r");
            
            // Read the first chunks
            f.read(chunk_0);
            f.read(chunk_1);
            f.read(chunk_2);
            
            // Determine the size of the Strg block
            f.seek(offset + 4);
            
            byte[] aux = new byte[4];
            f.read(aux);
            
            int size = byteSeqToInt(aux);   // unpadded size
            
            f.seek(offset);
            
            chunk_3 = new byte[size];
            
            f.read(chunk_3);
            
            offset += size;
            
            byte[] single = new byte[1];
            
            //System.out.println(offset);
            
            //System.out.println("entering first while");
            
            while (single[0] == 0){    // Deal with the padding
                f.read(single);
                if (single[0] == 0)
                    offset++;
                
            }
            
            //size_Strg = offset - start_Strg;
            
            // Read the next chunk
            f.seek(offset);
            
            f.read(chunk_4);
            
            offset += chunk_4.length;
            
            // Determine the size of the Sent block
            f.seek(offset + 4);
            
            f.read(aux);
            
            size = byteSeqToInt(aux);   // unpadded size
            
            f.seek(offset);
            
            chunk_5 = new byte[size];
            
            f.read(chunk_5);
            
            offset += size;
            
            single[0] = 0;
            
            //System.out.println("entering second while");
            
            while (single[0] == 0){    // Deal with the padding
                f.read(single);
                if (single[0] == 0)
                    offset++;
            }
            
            // Read the last chunk
            chunk_6 = new byte[(int) f.length() - offset];
            
            f.seek(offset);
            
            f.read(chunk_6);
            
            f.close();
            
            //System.out.println("First byte of chunk 6: " + chunk_6[0]);
            
            
            // ------------------------------------------------------------------ PARSING --------------------------------
            // Parse chunks 1, 3, 5 and 6
            messages = new String[num_categories];
            
            stringData = new DataString[num_categories][];
            
            offset = 12;
            aux = new byte[12];
                        
            
            // FIRST CHUNK - SPIRIT NAMES
            
            messages[0] = "Max. 12 characters per name";
            stringData[0] = new DataString[32];
            
            // This chunk contains 32 entries -this never changes-
            for (int i = 0; i < 32; i++){
                for (int j = 0; j < 12; j++)
                    aux[j] = chunk_1[offset + j];
                
                String t = new String(aux, font_encoding);
                
                t = t.trim();
                
                DataString d = new DataString(t, t, "");
                
                d.extra = new byte[4];
                
                for (int j = 12; j < 16; j++)
                    d.extra[j - 12] = chunk_1[offset + j];
                
                stringData[0][i] = d;
                
                offset += 16;
            }
            
            
            // THIRD CHUNK - STRINGS
            
            messages[1] = " ";
            stringData[1] = new DataString[50]; // Pilot skills
            messages[2] = " ";
            stringData[2] = new DataString[52]; // Unit abilities
            messages[3] = "Specs (width and height) are optional (some units don't have them)";
            stringData[3] = new DataString[555]; // Unit names + specs
            messages[4] = " ";
            stringData[4] = new DataString[19]; // Place names
            messages[5] = " ";
            stringData[5] = new DataString[452]; // Weapon names
            messages[6] = "Voice Actor is optional (some characters are not voiced)";
            stringData[6] = new DataString[594]; // Character names + VA
            messages[7] = " ";
            stringData[7] = new DataString[82]; // BGM names
            messages[8] = " ";
            stringData[8] = new DataString[35]; // Enhance part names
            
            aux = new byte[4];
            byte[] line;
            
            aux[0] = chunk_3[4];
            aux[1] = chunk_3[5];
            aux[2] = chunk_3[6];
            aux[3] = chunk_3[7];
            
            int max = byteSeqToInt(aux);
            int start;
            int end;
            
            offset = 12;
            
            // This chunk contains 1839 entries -this never changes-
            for (int i = 0; i < 1839; i++){
                aux[0] = chunk_3[offset];
                aux[1] = chunk_3[offset+1];
                aux[2] = chunk_3[offset+2];
                aux[3] = chunk_3[offset+3];
                
                start = byteSeqToInt(aux);
                
                if ( i < 1838 ){
                    aux[0] = chunk_3[offset+4];
                    aux[1] = chunk_3[offset+5];
                    aux[2] = chunk_3[offset+6];
                    aux[3] = chunk_3[offset+7];

                    end = byteSeqToInt(aux);
                }
                else
                    end = max;
                
                line = new byte[end - start];
                
                for (int j = start; j < end; j++)
                    line[j - start] = chunk_3[j];
                
                String t = new String(line, font_encoding);
                
                t = t.trim();
                
                DataString d = new DataString(t, t, "");
                
                int category_number;
                int adjustment = 0;
                
                if (i < 50)
                    category_number = 1;
                else if (i < 102){
                    category_number = 2;
                    adjustment = 50;
                }
                else if (i < 657){
                    category_number = 3;
                    adjustment = 102;
                }
                else if (i < 676){
                    category_number = 4;
                    adjustment = 657;
                }
                else if (i < 1128){
                    category_number = 5;
                    adjustment = 676;
                }
                else if (i < 1722){
                    category_number = 6;
                    adjustment = 1128;
                }
                else if (i < 1804){
                    category_number = 7;
                    adjustment = 1722;
                }
                else{
                    category_number = 8;
                    adjustment = 1804;
                }
                
                stringData[category_number][i - adjustment] = d;
                
                offset += 4;
            }
            
            
            // FIFTH CHUNK - SENT(ENCES?)
            
            messages[9] = " ";
            stringData[9] = new DataString[1092]; // Robot Library entries
            messages[10] = " ";
            stringData[10] = new DataString[3164]; // Character Library entries
            messages[11] = "Last entry *must* remain empty";
            stringData[11] = new DataString[40]; // Seishin descriptions
            messages[12] = "Last entry *must* remain empty";
            stringData[12] = new DataString[73]; // Pilot skill descriptions
            messages[13] = "Last entry *must* remain empty";
            stringData[13] = new DataString[98]; // Unit ability descriptions
            messages[14] = "Last entry *must* remain empty";
            stringData[14] = new DataString[77]; // Enhancement part descriptions
            messages[15] = "#157 and #158 have special characters - check the readme";
            stringData[15] = new DataString[744]; // Help strings
            
            aux = new byte[4];
            
            aux[0] = chunk_5[4];
            aux[1] = chunk_5[5];
            aux[2] = chunk_5[6];
            aux[3] = chunk_5[7];
            
            max = byteSeqToInt(aux);
            start = 0;
            end = 0;
            
            offset = 12;
            
            // This chunk contains 5288 entries -this never changes-
            for (int i = 0; i < 5288; i++){
                aux[0] = chunk_5[offset];
                aux[1] = chunk_5[offset+1];
                aux[2] = chunk_5[offset+2];
                aux[3] = chunk_5[offset+3];
                
                start = byteSeqToInt(aux);
                
                if ( i < 5287 ){
                    aux[0] = chunk_5[offset+4];
                    aux[1] = chunk_5[offset+5];
                    aux[2] = chunk_5[offset+6];
                    aux[3] = chunk_5[offset+7];

                    end = byteSeqToInt(aux);
                }
                else
                    end = max;
                
                line = new byte[end - start];
                
                for (int j = start; j < end; j++)
                    line[j - start] = chunk_5[j];
                
                String t = new String(line, font_encoding);
                
                t = t.trim();
                
                DataString d = new DataString(t, t, "");
                
                int category_number = 0;
                int adjustment = 0;
                
                if (i < 1092)
                    category_number = 9;
                else if (i < 4256){
                    category_number = 10;
                    adjustment = 1092;
                }
                else if (i < 4296){
                    category_number = 11;
                    adjustment = 4256;
                }
                else if (i < 4369){
                    category_number = 12;
                    adjustment = 4296;
                }
                else if (i < 4467){
                    category_number = 13;
                    adjustment = 4369;
                }
                else if (i < 4544){
                    category_number = 14;
                    adjustment = 4467;
                }
                else{
                    category_number = 15;
                    adjustment = 4544;
                }
                
                stringData[category_number][i - adjustment] = d;
                
                offset += 4;
            }
            
            // LAST CHUNK - MULTI-BLOCK
            
            /*
            The multi-block is divided in 5 sections. First 20 bites are 5 4-byte pointers for these.
             - The first one has no text at all, so we save that one to reinsert it later.
             - Second one is a set of 14 88-byte blocks containing text (stage names?). Each block has 56 bytes for text
              and 32 reserved for unknown data.
             - Third one has 69 blocks of 136 bytes each containing location names. First 4 bytes are empty, and then 80 bytes
              for the terrain name and 52 for the terrain type (written in text)
             - Fourth one is also 69 blocks, these have 128 bytes each and also seem to have stage names.
              First 16 bytes are a header, followed by two blocks of 56 bytes containing the exact same text
             - Fifth and last section has a pointer table at the beginning, also with 69 entries. Each entry
              can have several lines separated by @ characters in SJIS (81 97)
            
            * We assume that the only section that can grow is the fifth one.
            */
            
            // Save the first section
            // This includes the section table at the beginning, yes.
            // We include it here because the only part that grows is the last one, so the table doesn't change
            for (int i = 0; i < 416; i++)
                multi_1[i] = chunk_6[i];
            
            // Parse the second section
            aux = new byte[56];
            byte[] extra = new byte[32];
            offset = 416;
            
            messages[16] = "Max. 56 characters per entry";
            stringData[16] = new DataString[14];
            
            for (int i = 0; i < 14; i++){
                int counter = 0;
                
                for (int j = (offset + i*88); j < (offset + (i+1)*88); j++){
                    if (counter < 56){
                        aux[counter] = chunk_6[j];
                    }
                    else{
                        extra[counter - 56] = chunk_6[j];
                    }
                    counter++;
                }
                
                String t = new String(aux, font_encoding);
                
                t = t.trim();
                
                DataString d = new DataString(t, t, "");
                
                d.storeExtra(extra);
                
                stringData[16][i] = d;
            }
            
            
            // Parse the third section
            aux = new byte[80];
            extra = new byte[8];
            byte[] extra2 = new byte[44];
            byte[] preamble = new byte[4];
            offset = 1648;
            
            messages[17] = "Max. 80 chars per location, 8 chars per terrain type";
            stringData[17] = new DataString[69];
            
            for (int i = 0; i < 69; i++){
                int counter = 0;
                
                for (int j = (offset + i*136); j < (offset + (i+1)*136); j++){
                    if (counter < 4){
                        preamble[counter] = chunk_6[j];
                    }
                    else if (counter < 84){
                        aux[counter - 4] = chunk_6[j];
                    }
                    else if (counter < 92){
                        extra[counter - 84] = chunk_6[j];
                    }
                    else
                        extra2[counter - 92] = chunk_6[j];
                    
                    counter++;
                }
                
                //String t = new String(aux, "Shift-JIS");
                String t = new String(aux, font_encoding);
                
                t = t.trim();
                
                //String t2 = new String(extra, "Shift-JIS");
                String t2 = new String(extra, font_encoding);
                
                t2 = t2.trim();
                
                DataString d = new DataString(t, t2, t, t2, "");
                
                d.storeExtra(preamble);
                d.storeExtra2(extra2);
                
                stringData[17][i] = d;
            }
            
            
            // Parse the fourth section
            aux = new byte[56];
            extra = new byte[16];
            offset = 11032;
            
            messages[18] = "Max. 56 characters per entry";
            stringData[18] = new DataString[69];
            
            for (int i = 0; i < 69; i++){
                int counter = 0;
                
                for (int j = (offset + i*128); j < ((offset + (i+1)*128) - 56); j++){   // We only take the first instance of the stage name (both are identical)
                    if (counter < 16){
                        extra[counter] = chunk_6[j];
                    }
                    else{
                        aux[counter - 16] = chunk_6[j];
                    }
                    counter++;
                }
                
                //String t = new String(aux, "Shift-JIS");
                String t = new String(aux, font_encoding);
                
                t = t.trim();
                                
                DataString d = new DataString(t, t, "");
                
                d.storeExtra(extra);
                
                stringData[18][i] = d;
            }
            
            
            // Parse the fifth section
            messages[19] = " ";
            stringData[19] = new DataString[69];
            
            aux = new byte[4];
            
            start = 0;
            end = 0;
            
            offset = 19868; // Start of pointers
            int base_offset = 19864;    // Start of section
            
            for (int i = 0; i < 69; i++){
                aux[0] = chunk_6[offset];
                aux[1] = chunk_6[offset+1];
                aux[2] = chunk_6[offset+2];
                aux[3] = chunk_6[offset+3];
                
                start = byteSeqToInt(aux);
                
                if ( i < 68 ){
                    aux[0] = chunk_6[offset+4];
                    aux[1] = chunk_6[offset+5];
                    aux[2] = chunk_6[offset+6];
                    aux[3] = chunk_6[offset+7];

                    end = byteSeqToInt(aux);
                }
                else{
                    end = chunk_6.length - base_offset; // This way we'd take everything until the end of the chunk
                }
                
                line = new byte[end - start];
                
                for (int j = start + base_offset; j < (end + base_offset); j++)
                    line[j - (start + base_offset)] = chunk_6[j];
                
                //String t = new String(line, "Shift-JIS");
                String t = new String(line, font_encoding);
                
                t = t.trim();   // Clean the empty 00 bytes at the end
                
                String[] lines = t.split("＠"); // Lines are separated using the ＠ symbol (it's in SJIS)
                
                t = lines[0];
                
                for (int j = 1; j < lines.length; j++){
                    t += "\n" + lines[j];
                }
                
                DataString d = new DataString(t, t, "");
                
                stringData[19][i] = d;
                
                offset += 4;
            }
            
            // END
            System.out.println("Parsed");            
            
            // Enable navigation
            file_loaded = true;
            comboCategory.setEnabled(file_loaded);

        } catch (IOException ex) {
            Logger.getLogger(UserInterfaceSDE.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    
    
    public void saveFile(String path, boolean use_converted){
        /*
        We have to join all chunks from 0 to 6 again into a file. Chunks 1, 3, 5 and 6 will have to be rebuilt before that.
        */
        
        byte[] aux;

        int offset;
        int size;
        int total_size = chunk_0.length + chunk_1.length + chunk_2.length;
        
        // Update the start of chunk_3 (Strg) inside the table at the beginning of chunk_0
        chunk_0[64] = (byte) (total_size & 0xff);
        chunk_0[65] = (byte) ( (total_size >> 8) & 0xff);
        chunk_0[66] = (byte) ( (total_size >> 16) & 0xff);
        chunk_0[67] = (byte) ( (total_size >> 24) & 0xff);

        ByteArrayOutputStream os;

        try{
            if (use_converted){ // Convert the edited text into letter pairs first
                for (int i = 0; i < stringData.length; i++){
                    for (int j = 0; j < stringData[i].length; j++)
                        stringData[i][j].convertLetterPairs();
                }
            }
            
            
            // ------------------------------------- REBUILD CHUNK 1 (seishin names)
            // There's no real need to rebuild it, just replace the strings
            offset = 12;

            for (int i = 0; i < 32; i++){
                aux = stringData[0][i].getBytes(use_converted);
                
                if (aux.length > 12){
                    for (int j = 0; j < 12; j++)
                        chunk_1[offset + j] = aux[j];
                }
                else{
                    for (int j = 0; j < aux.length; j++)
                        chunk_1[offset + j] = aux[j];
                    for (int j = aux.length; j < 12; j++)
                        chunk_1[offset + j] = 0;
                }
                
                offset += 16;
            }
        
            
            // ------------------------------------- REBUILD CHUNK 3 (Strings)
            // Chunk 3 has sections 1 to 8
            
            offset = 0;
            byte[] pre_chunk3 = new byte[12];
            byte[] table_chunk3 = new byte[1839*4];
            byte[] padding_chunk3 = null;
            size = 12 + 1839*4;
            
            os = new ByteArrayOutputStream();
            
            // Identifier of the chunk
            pre_chunk3[0] = 'S';
            pre_chunk3[1] = 't';
            pre_chunk3[2] = 'r';
            pre_chunk3[3] = 'g';
            
            // bytes 4 - 7 have the size of the unpadded data
            
            // Entries in the table
            pre_chunk3[8] = 0x2f;
            pre_chunk3[9] = 0x07;
            
            // Prepare the table
            int entry_counter = 0;
            
            for (int i = 1; i < 9; i++){
                for (int j = 0; j < stringData[i].length; j++){
                    // Write offset in the table
                    int written_offset = offset + 12 + table_chunk3.length;
                    table_chunk3[entry_counter*4] = (byte) ( written_offset & 0xff );
                    table_chunk3[entry_counter*4 + 1] = (byte) ( (written_offset >> 8)  & 0xff );
                    table_chunk3[entry_counter*4 + 2] = (byte) ( (written_offset >> 16) & 0xff );
                    table_chunk3[entry_counter*4 + 3] = (byte) ( (written_offset >> 24) & 0xff );

                    aux = stringData[i][j].getBytes(use_converted);
                    offset += aux.length;

                    os.write(aux);
                    
                    entry_counter++;
                }
            }
            
            size += offset;
            
            pre_chunk3[4] = (byte) (size & 0xff);
            pre_chunk3[5] = (byte) ( (size >> 8) & 0xff);
            pre_chunk3[6] = (byte) ( (size >> 16) & 0xff);
            pre_chunk3[7] = (byte) ( (size >> 24) & 0xff);
            
            chunk_3 = os.toByteArray(); // no need to keep the old chunk
            
            total_size += pre_chunk3.length;
            total_size += table_chunk3.length;
            total_size += chunk_3.length;
            
            // Calculate the padding of the chunk
            // It's still not clear if this section is 16 or 32-byte alligned
            int rest = size % 16;
            if (rest != 0){
                padding_chunk3 = new byte[16 - rest];
                total_size += padding_chunk3.length;
            }
            
            
            // Update the start of chunk_4 (Xunt) inside the table at the beginning of chunk_0
            chunk_0[68] = (byte) (total_size & 0xff);
            chunk_0[69] = (byte) ( (total_size >> 8) & 0xff);
            chunk_0[70] = (byte) ( (total_size >> 16) & 0xff);
            chunk_0[71] = (byte) ( (total_size >> 24) & 0xff);
            
            // Update the offsets for the other sections between Strg and Sent
            //total_size += chunk_4.length;
            total_size += 5576; // The size of Xunt
            
            chunk_0[72] = (byte) (total_size & 0xff);
            chunk_0[73] = (byte) ( (total_size >> 8) & 0xff);
            chunk_0[74] = (byte) ( (total_size >> 16) & 0xff);
            chunk_0[75] = (byte) ( (total_size >> 24) & 0xff);
            
            total_size += 7312; // The size of XPlt
            
            chunk_0[76] = (byte) (total_size & 0xff);
            chunk_0[77] = (byte) ( (total_size >> 8) & 0xff);
            chunk_0[78] = (byte) ( (total_size >> 16) & 0xff);
            chunk_0[79] = (byte) ( (total_size >> 24) & 0xff);
            
            total_size += 284; // The size of XSpr
            
            chunk_0[80] = (byte) (total_size & 0xff);
            chunk_0[81] = (byte) ( (total_size >> 8) & 0xff);
            chunk_0[82] = (byte) ( (total_size >> 16) & 0xff);
            chunk_0[83] = (byte) ( (total_size >> 24) & 0xff);
            
            total_size += 460; // The size of XSkl
            
            chunk_0[84] = (byte) (total_size & 0xff);
            chunk_0[85] = (byte) ( (total_size >> 8) & 0xff);
            chunk_0[86] = (byte) ( (total_size >> 16) & 0xff);
            chunk_0[87] = (byte) ( (total_size >> 24) & 0xff);
            
            total_size += 532; // The size of Xabl
            
            chunk_0[88] = (byte) (total_size & 0xff);
            chunk_0[89] = (byte) ( (total_size >> 8) & 0xff);
            chunk_0[90] = (byte) ( (total_size >> 16) & 0xff);
            chunk_0[91] = (byte) ( (total_size >> 24) & 0xff);
            
            total_size += 396; // The size of XPrt
            
            chunk_0[92] = (byte) (total_size & 0xff);
            chunk_0[93] = (byte) ( (total_size >> 8) & 0xff);
            chunk_0[94] = (byte) ( (total_size >> 16) & 0xff);
            chunk_0[95] = (byte) ( (total_size >> 24) & 0xff);
            
            total_size += 4556; // The size of XHlp
            
            chunk_0[96] = (byte) (total_size & 0xff);
            chunk_0[97] = (byte) ( (total_size >> 8) & 0xff);
            chunk_0[98] = (byte) ( (total_size >> 16) & 0xff);
            chunk_0[99] = (byte) ( (total_size >> 24) & 0xff);
            
            
            // ------------------------------------- REBUILD CHUNK 5 (Sentences)
            // Chunk 5 has sections 9 to 15
            
            offset = 0;
            byte[] pre_chunk5 = new byte[12];
            byte[] table_chunk5 = new byte[5288*4];
            byte[] padding_chunk5 = null;
            size = 12 + 5288*4;
            
            os = new ByteArrayOutputStream();
            
            // Identifier of the chunk
            pre_chunk5[0] = 'S';
            pre_chunk5[1] = 'e';
            pre_chunk5[2] = 'n';
            pre_chunk5[3] = 't';
            
            // bytes 4 - 7 have the size of the unpadded data
            
            // Entries in the table
            pre_chunk5[8] = (byte) (0xa8 & 0xff);
            pre_chunk5[9] = 0x14;
            
            // Prepare the table
            entry_counter = 0;
            
            for (int i = 9; i < 16; i++){
                for (int j = 0; j < stringData[i].length; j++){
                    // Write offset in the table
                    int written_offset = offset + 12 + table_chunk5.length;
                    table_chunk5[entry_counter*4] = (byte) ( written_offset & 0xff );
                    table_chunk5[entry_counter*4 + 1] = (byte) ( (written_offset >> 8)  & 0xff );
                    table_chunk5[entry_counter*4 + 2] = (byte) ( (written_offset >> 16) & 0xff );
                    table_chunk5[entry_counter*4 + 3] = (byte) ( (written_offset >> 24) & 0xff );

                    aux = stringData[i][j].getBytes(use_converted);
                    offset += aux.length;

                    os.write(aux);
                    
                    entry_counter++;
                }
            }
            
            size += offset;
            
            pre_chunk5[4] = (byte) (size & 0xff);
            pre_chunk5[5] = (byte) ( (size >> 8) & 0xff);
            pre_chunk5[6] = (byte) ( (size >> 16) & 0xff);
            pre_chunk5[7] = (byte) ( (size >> 24) & 0xff);
            
            chunk_5 = os.toByteArray(); // no need to keep the old chunk
            
            total_size += pre_chunk5.length;
            total_size += table_chunk5.length;
            total_size += chunk_5.length;
            
            // Calculate the padding of the chunk
            // It seems the next chunk has to start at a multiple of 64 (?)
            //System.out.println("Accumulated before multi-part: " + total_size);
            rest = total_size % 384;
            if (rest != 0){
                padding_chunk5 = new byte[384 - rest];
                total_size += padding_chunk5.length;
            }
            
            
            // ------------------------------------- REBUILD CHUNK 6 (Multi)
            // Chunk 6 has sections 16 to 19, aside from multi_1 at the beginning
            // Sections 16 - 18 have special formats, section 19 has a table
            
            os = new ByteArrayOutputStream();
            byte[] multi_2_4;
            
            // Rebuild section multi_2
            
            for (int i = 0; i < stringData[16].length; i++){
                aux = new byte[88];
                byte[] aux_string = stringData[16][i].getBytes(use_converted);
                
                if (aux_string.length > 56){
                    for (int j = 0; j < 56; j++)
                        aux[j] = aux_string[j];
                }
                else{
                    for (int j = 0; j < aux_string.length; j++)
                        aux[j] = aux_string[j];
                }
                
                int counter = 0;
                
                for (int j = 56; j < 88; j++){
                    aux[j] = stringData[16][i].extra[counter];
                    counter++;
                }
                
                os.write(aux);
            }
            
            // Rebuild section multi_3
            
            for (int i = 0; i < stringData[17].length; i++){
                aux = new byte[136];
                byte[] aux_string = stringData[17][i].getBytes(use_converted);
                byte[] aux_string2 = stringData[17][i].getBytes2(use_converted);
                
                // Write the preamble
                aux[0] = stringData[17][i].extra[0];
                aux[1] = stringData[17][i].extra[1];
                aux[2] = stringData[17][i].extra[2];
                aux[3] = stringData[17][i].extra[3];
                
                // Write the location
                if (aux_string.length > 80){
                    for (int j = 0; j < 80; j++)
                        aux[j + 4] = aux_string[j];
                }
                else{
                    for (int j = 0; j < aux_string.length; j++)
                        aux[j + 4] = aux_string[j];
                }
                
                // Write the terrain
                if (aux_string2.length > 8){
                    for (int j = 0; j < 8; j++)
                        aux[j + 84] = aux_string2[j];
                }
                else{
                    for (int j = 0; j < aux_string2.length; j++)
                        aux[j + 84] = aux_string2[j];
                }
                
                // Write the extra data
                int counter = 0;
                
                for (int j = 92; j < 136; j++){
                    aux[j] = stringData[17][i].extra2[counter];
                    counter++;
                }
                
                os.write(aux);
            }
            
            // Rebuild section multi_4

            for (int i = 0; i < stringData[18].length; i++){
                aux = new byte[128];
                byte[] aux_string = stringData[18][i].getBytes(use_converted);
                
                // Write the header
                for (int j = 0; j < 16; j++)
                    aux[j] = stringData[18][i].extra[j];
                    
                // Write the stage name *twice*
                if (aux_string.length > 56){
                    for (int j = 0; j < 56; j++){
                        aux[j + 16] = aux_string[j];
                        aux[j + 72] = aux_string[j];
                    }
                }
                else{
                    for (int j = 0; j < aux_string.length; j++){
                        aux[j + 16] = aux_string[j];
                        aux[j + 72] = aux_string[j];
                    }
                }
                
                os.write(aux);
            }
            
            // Get sections 2 - 4 together
            multi_2_4 = os.toByteArray();
            
            total_size += multi_1.length;
            total_size += multi_2_4.length;
            
            
            // Rebuild section multi_5
            
            offset = 0;
            byte[] pre_chunk6 = new byte[4];
            byte[] table_chunk6 = new byte[69*4];
            byte[] padding_chunk6 = null;
            
            os = new ByteArrayOutputStream();
            
            // Entries in the table
            pre_chunk6[0] = 0x45;
            
            // Prepare the table
            for (int i = 0; i < stringData[19].length; i++){
                // Write offset in the table
                int written_offset = offset + 4  + table_chunk6.length;
                table_chunk6[i*4] = (byte) ( written_offset & 0xff );
                table_chunk6[i*4 + 1] = (byte) ( (written_offset >> 8)  & 0xff );
                table_chunk6[i*4 + 2] = (byte) ( (written_offset >> 16) & 0xff );
                table_chunk6[i*4 + 3] = (byte) ( (written_offset >> 24) & 0xff );

                aux = stringData[19][i].getBytes(use_converted);
                offset += aux.length;

                os.write(aux);
            }
                        
            chunk_6 = os.toByteArray(); // no need to keep the old chunk
            
            total_size += pre_chunk6.length;
            total_size += table_chunk6.length;
            total_size += chunk_6.length;
            
            // Calculate the padding of the chunk
            // It seems the next chunk has to start at a multiple of 64 (?)
            rest = total_size % 64;
            if (rest != 0){
                padding_chunk6 = new byte[64 - rest];
                total_size += padding_chunk6.length;
            }
            
            
            
            // ------------------------------------- WRITE EVERYTHING!!
            RandomAccessFile f = new RandomAccessFile(path, "rw");

            f.write(chunk_0);
            f.write(chunk_1);
            f.write(chunk_2);
            
            f.write(pre_chunk3);
            f.write(table_chunk3);
            f.write(chunk_3);
            
            if (padding_chunk3 != null)
                f.write(padding_chunk3);

            f.write(chunk_4);
            
            f.write(pre_chunk5);
            f.write(table_chunk5);
            f.write(chunk_5);
            
            if (padding_chunk5 != null)
                f.write(padding_chunk5);

            f.write(multi_1);
            f.write(multi_2_4);
            
            f.write(pre_chunk6);
            f.write(table_chunk6);
            f.write(chunk_6);
            
            if (padding_chunk5 != null)
                f.write(padding_chunk6);
            
            f.close();

            System.out.println("File " + path + " saved successfully.");    // END

        } catch(IOException ex){
            JOptionPane.showMessageDialog(null, "Could not write file to disk!",
                    "Error", JOptionPane.ERROR_MESSAGE);
            Logger.getLogger(UserInterfaceSDE.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    
        
    // Takes a 4-byte hex little endian and returns its int value
    // Takes little endian values
    public int byteSeqToInt(byte[] byteSequence){
        if (byteSequence.length != 4)
            return -1;

        int value = 0;
        value += byteSequence[0] & 0xff;
        value += (byteSequence[1] & 0xff) << 8;
        value += (byteSequence[2] & 0xff) << 16;
        value += (byteSequence[3] & 0xff) << 24;
        return value;
    }


    public String hex2string(byte[] sjis_bytes){
        String sjis_text = "";

        try {
            sjis_text = new String(sjis_bytes, font_encoding);
        } catch (UnsupportedEncodingException ex) {
            Logger.getLogger(UserInterfaceSDE.class.getName()).log(Level.SEVERE, null, ex);
        }

        return sjis_text;
    }
    
    
    
    public void changeCategory(int cat){
        saveCategory();
        current_category = cat;
        loadCategory();
    }


    public void saveCategory(){
        Component[] blines = panelLines.getComponents();

        for (int i = 0; i < blines.length; i++){
            if (current_category == 17){
                PanelStringDouble bld = (PanelStringDouble) blines[i];
                stringData[current_category][i].edited = bld.getEditText();
                stringData[current_category][i].edited2 = bld.getEditText2();
            }
            else if (current_category == 19){
                PanelStringLarge bl = (PanelStringLarge) blines[i];
                stringData[current_category][i].edited = bl.getEditText();
            }
            else{
                PanelString bl = (PanelString) blines[i];
                stringData[current_category][i].edited = bl.getEditText();
            }
        }
    }


    public void loadCategory(){
        panelLines.removeAll();
        //panelLines.repaint();

        int offX = 7;
        int offY = 10;

        int totalHeight = 20;

        for (int i = 0; i < stringData[current_category].length; i++){
            if (current_category == 17){
                PanelStringDouble psd = new PanelStringDouble();

                psd.setID(i + 1);
                psd.setOriginalText(stringData[current_category][i].original);
                psd.setOriginalText2(stringData[current_category][i].original2);
                psd.setEditText(stringData[current_category][i].edited);
                psd.setEditText2(stringData[current_category][i].edited2);
                psd.setSJIS(checkSJIS.isSelected());

                psd.setBounds(offX, i*186 + offY, 850, 180);

                panelLines.add(psd);

                totalHeight += 186;
            }
            else if (current_category == 19){
                PanelStringLarge ps = new PanelStringLarge();

                ps.setID(i + 1);
                ps.setOriginalText(stringData[current_category][i].original);
                ps.setEditText(stringData[current_category][i].edited);
                ps.setSJIS(checkSJIS.isSelected());

                ps.setBounds(offX, i*186 + offY, 850, 180);

                panelLines.add(ps);

                totalHeight += 186;
            }
            else{
                PanelString ps = new PanelString();

                ps.setID(i + 1);
                ps.setOriginalText(stringData[current_category][i].original);
                ps.setEditText(stringData[current_category][i].edited);
                ps.setSJIS(checkSJIS.isSelected());

                ps.setBounds(offX, i*115 + offY, 850, 109);

                panelLines.add(ps);

                totalHeight += 115;
            }
        }

        panelLines.setPreferredSize(new Dimension(panelLines.getWidth() - 20, totalHeight));
        //panelLines.repaint();
        //scrollStrings.repaint();
        scrollStrings.revalidate();
        
        labelInfo.setText(messages[current_category]);
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JCheckBoxMenuItem checkSJIS;
    private javax.swing.JComboBox comboCategory;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JPopupMenu.Separator jSeparator1;
    private javax.swing.JPopupMenu.Separator jSeparator2;
    private javax.swing.JLabel labelCategory;
    private javax.swing.JLabel labelInfo;
    private javax.swing.JMenu menuFile;
    private javax.swing.JMenu menuTools;
    private javax.swing.JMenuItem menuitemClose;
    private javax.swing.JMenuItem menuitemConvert;
    private javax.swing.JMenuItem menuitemConvertSJIS;
    private javax.swing.JMenuItem menuitemOpen;
    private javax.swing.JMenuItem menuitemSave;
    private javax.swing.JPanel panelLines;
    private javax.swing.JPanel panelNavigation;
    private javax.swing.JScrollPane scrollStrings;
    // End of variables declaration//GEN-END:variables
}
